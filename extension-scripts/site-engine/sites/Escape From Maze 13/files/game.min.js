//see bling.js
window.$ = document.querySelectorAll.bind(document)
Node.prototype.on = window.on = function (name, fn) {
  this.addEventListener(name, fn)
}
NodeList.prototype.__proto__ = Array.prototype
NodeList.prototype.on = NodeList.prototype.addEventListener = function (name, fn) {
  this.forEach(function (elem, i) {
    elem.on(name, fn)
  })
}

//see https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework
var docCookies = {
  getItem: function (sKey) {
    if (!sKey) { return null; }
    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
  },
  setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
    var sExpires = "";
    if (vEnd) {
      switch (vEnd.constructor) {
        case Number:
          sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
          break;
        case String:
          sExpires = "; expires=" + vEnd;
          break;
        case Date:
          sExpires = "; expires=" + vEnd.toUTCString();
          break;
      }
    }
    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
    return true;
  }
};

const cmp = {none:0, west:1, east:2,north:4,south:8} //directions cmp as in 
const gs = {start:0, starting:1, pause:2, play:3, win:4}//game state
const cell = 40;

class Util
{
  static rand(a, b) {
	    return ~~(Math.random() * (b - a) + a);
  };
}


/* SfxrParams */
function SfxrParams(){this.setSettings=function(a){for(var b=0;b<24;b++)this[String.fromCharCode(97+b)]=a[b]||0;this.c<.01&&(this.c=.01);var c=this.b+this.c+this.e;if(c<.18){var d=.18/c;this.b*=d,this.c*=d,this.e*=d}}}function SfxrSynth(){this._params=new SfxrParams;var a,b,c,d,e,f,g,h,i,j,k,l;this.reset=function(){var a=this._params;d=100/(a.f*a.f+.001),e=100/(a.g*a.g+.001),f=1-a.h*a.h*a.h*.01,g=-a.i*a.i*a.i*1e-6,a.a||(k=.5-a.n/2,l=5e-5*-a.o),h=1+a.l*a.l*(a.l>0?-.9:10),i=0,j=1==a.m?0:(1-a.m)*(1-a.m)*2e4+32},this.totalReset=function(){this.reset();var d=this._params;return a=d.b*d.b*1e5,b=d.c*d.c*1e5,c=d.e*d.e*1e5+12,3*((a+b+c)/3|0)},this.synthWave=function(m,n){var o=this._params,p=1!=o.s||o.v,q=o.v*o.v*.1,r=1+3e-4*o.w,s=o.s*o.s*o.s*.1,t=1+1e-4*o.t,u=1!=o.s,v=o.x*o.x,w=o.g,x=o.q||o.r,y=o.r*o.r*o.r*.2,z=o.q*o.q*(o.q<0?-1020:1020),A=o.p?((1-o.p)*(1-o.p)*2e4|0)+32:0,B=o.d,C=o.j/2,D=o.k*o.k*.01,E=o.a,F=a,G=1/a,H=1/b,I=1/c,J=5/(1+o.u*o.u*20)*(.01+s);J>.8&&(J=.8),J=1-J;for(var Q,S,U,W,Y,Z,K=!1,L=0,M=0,N=0,O=0,P=0,R=0,T=0,V=0,X=0,$=0,_=new Array(1024),aa=new Array(32),ba=_.length;ba--;)_[ba]=0;for(var ba=aa.length;ba--;)aa[ba]=2*Math.random()-1;for(var ba=0;ba<n;ba++){if(K)return ba;if(A&&++X>=A&&(X=0,this.reset()),j&&++i>=j&&(j=0,d*=h),f+=g,d*=f,d>e&&(d=e,w>0&&(K=!0)),S=d,C>0&&($+=D,S*=1+Math.sin($)*C),S|=0,S<8&&(S=8),E||(k+=l,k<0?k=0:k>.5&&(k=.5)),++M>F)switch(M=0,++L){case 1:F=b;break;case 2:F=c}switch(L){case 0:N=M*G;break;case 1:N=1+2*(1-M*H)*B;break;case 2:N=1-M*I;break;case 3:N=0,K=!0}x&&(z+=y,U=0|z,U<0?U=-U:U>1023&&(U=1023)),p&&r&&(q*=r,q<1e-5?q=1e-5:q>.1&&(q=.1)),Z=0;for(var ca=8;ca--;){if(T++,T>=S&&(T%=S,3==E))for(var da=aa.length;da--;)aa[da]=2*Math.random()-1;switch(E){case 0:Y=T/S<k?.5:-.5;break;case 1:Y=1-T/S*2;break;case 2:W=T/S,W=6.28318531*(W>.5?W-1:W),Y=1.27323954*W+.405284735*W*W*(W<0?1:-1),Y=.225*((Y<0?-1:1)*Y*Y-Y)+Y;break;case 3:Y=aa[Math.abs(32*T/S|0)]}p&&(Q=R,s*=t,s<0?s=0:s>.1&&(s=.1),u?(P+=(Y-R)*s,P*=J):(R=Y,P=0),R+=P,O+=R-Q,O*=1-q,Y=O),x&&(_[V%1024]=Y,Y+=_[(V-U+1024)%1024],V++),Z+=Y}Z*=.125*N*v,m[ba]=Z>=1?32767:Z<=-1?-32768:32767*Z|0}return n}}var synth=new SfxrSynth;window.jsfxr=function(a){synth._params.setSettings(a);var b=synth.totalReset(),c=new Uint8Array(4*((b+1)/2|0)+44),d=2*synth.synthWave(new Uint16Array(c.buffer,44),b),e=new Uint32Array(c.buffer,0,44);e[0]=1179011410,e[1]=d+36,e[2]=1163280727,e[3]=544501094,e[4]=16,e[5]=65537,e[6]=44100,e[7]=88200,e[8]=1048578,e[9]=1635017060,e[10]=d,d+=44;for(var f=0,g="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",h="data:audio/wav;base64,";f<d;f+=3){var i=c[f]<<16|c[f+1]<<8|c[f+2];h+=g[i>>18]+g[i>>12&63]+g[i>>6&63]+g[63&i]}return h};
 
class Sound{

    tglMute(){
      this.mute = !this.mute;
    }
 
  hit(){
    Snd._play([1,,0.0246,,0.1553,0.5731,,-0.6532,,,,,,,,,,,1,,,0.0082,,0.32]);
  }

  start(){
    Snd._play([1,,0.1254,,0.288,0.73,,0.06,,0.3725,0.0526,,,,,,,,0.89,-0.56,,,-0.76,0.71]);
  }

  enter(){
    Snd._play([1,0.0045,0.9759,0.0426,0.9729,0.8504,,,-0.0021,-0.0301,-0.2691,-0.876,0.3828,0.8763,-0.0121,-0.2677,0.0074,-0.0004,0.7604,-0.265,-0.4473,0.0048,,0.49]);
  }

  glitch(){
    Snd._play([3,1,0.01,,0.221,0.23,,-0.64,-0.42,,,0.1399,,0.1209,,,-0.76,-0.86,0.5141,,,,,0.71]);
  }

 end(){
   Snd._play([2,0.0058,0.385,0.1384,0.4848,0.5559,,-0.0009,,,0.4078,-0.1889,,0.3744,-0.015,0.0006,,-0.0007,0.996,0.1962,,0.3422,-0.0003,0.256]);
  }

   _play(snd){
      if(this.mute) return;
      var player = new Audio();
      player.src =  jsfxr(snd);
      player.play();
  }

}

const Snd = new Sound();
class Score{

  static top(sz)
  {
    let t = docCookies.getItem("score" + sz);
    if(!t) return "";

    let s =  Math.floor((t/1000) % 60);
    let m = Math.floor((t/1000/60) % 60 );
    let ms =  ('0'+Math.floor(t%60)).slice(-2);

    return `${m}m ${s}s ${ms}ms`;
  }

  static set(sz,tm)
  {
      let v = docCookies.getItem("score" + sz);
      if(!v || v > tm){
          docCookies.setItem("score" + sz, tm)
      }
  }

}
class Glitch {

  constructor(max) {
    this.x = Util.rand(1, max) * 40;
    this.y = Util.rand(1, max) * 40;
    this.r = 0;//radius
    this.g = 0.2;
    this.isDead=false;
    this.isHit = false;
  }

  update(p) {
    if(Util.rand(1, 100)%10){this.r = Util.rand(1, 40);this.flip=Util.rand(1, 10)};
 
    if ((!this.isHit) && (p.x < this.x + cell &&  p.x + cell > this.x &&  p.y < this.y + cell && cell + p.y > this.y)) {
        this._gen();
         Snd.glitch();
        let gi = setInterval(() => {
             setTimeout(() => { this._gen() }, Util.rand(250, 1000));
        }, 500);

        setTimeout(() => { 
          clearInterval(gi);
          this.isDead = true;
        }, 2000);

        this.isHit = true;
    }    
}
  

  _gen() {
    this.lines = [];

    let h = this.h;
    let w = this.w;
    let ln = Util.rand(1, 13);

    for (let i = 0; i < ln; i++) {

      let xv = Math.random() * w;
      let ln = {
        x: xv,
        y: Math.random() * h,
        spliceWidth: w - xv,
        spliceHeight: Util.rand(5, h / 3)
      }

      this.lines.push(ln);
    }
  }

  render(c) {

    this.w = c.canvas.width;
    this.h = c.canvas.height;

    if(this.isDead)
      return;

    c.save();
    c.translate(this.x, this.y);

    if(this.flip%2==0){c.moveTo(0, this.r);c.lineTo(40, this.r);}else{c.moveTo(this.r, 0);c.lineTo(this.r, 40);}

    c.strokeStyle = "#6f6";
    c.stroke();
    c.restore();
  
      if (this.isHit && this.lines) {
        this.lines.forEach(function (ln) {
          c.globalAlpha = 0.7;
          c.drawImage(c.canvas, 0, ln.y, ln.spliceWidth, ln.spliceHeight, ln.x, ln.y, ln.spliceWidth, ln.spliceHeight);
          c.drawImage(c.canvas, ln.spliceWidth, ln.y, ln.x, ln.spliceHeight, 0, ln.y, ln.x, ln.spliceHeight);
        });
      }
    }
  }
 
class Maze{
   
  build(sz)
  {
    this.sz = sz;
    this.maze = this._create2DArray(sz);
    this._carvePassagesTo(0, 0, "N");
    this.maze[sz-1][sz-1] = this.maze[sz-1][sz-1] & ~cmp.south;//make exit
  }

  _carvePassagesTo(x, y, fromDirection){

    //intilize cell to mark as visited
    this.maze[x][y] = cmp.none;
  
    const directions = [{name:"N",opposite:"S",x:0,y:-1,wall: cmp.north},{name:"S",opposite:"N",x:0,y:1,wall: cmp.south}, {name:"E",opposite:"W",x:1,y:0, wall: cmp.east}, {name:"W",opposite:"E",x:-1,y:0,wall: cmp.west}];
    const randomDirections = this._shuffleArray(directions);

    randomDirections.forEach((headingDirection)=>{

        if(this._canVisit(x,y,x+headingDirection.x, y+headingDirection.y))
        {
          this._carvePassagesTo(x+headingDirection.x, y+headingDirection.y, headingDirection.opposite); 
        }else if(fromDirection != headingDirection.name) {
          this.maze[x][y] = this.maze[x][y] | headingDirection.wall;//build wall
        }
        
      })

  }
            
  _canVisit(x,y,targetX, targetY)
  {
    return !((targetX < 0 || targetX >= this.sz) || (targetY < 0 || targetY >= this.sz)||(this.maze[targetX][targetY] != null))
  }

  _create2DArray(rows) {
    var arr = [];

    for (var i=0;i<rows;i++) {
      arr[i] = [];
      for (var j=0;j<rows;j++) {
          arr[i].push(null);
      }
      
    }

    return arr;
  }
  
  /**
   * Randomize array element order in-place.
   * Using Durstenfeld shuffle algorithm.
   * see http://stackoverflow.com/a/12646864/33
   */
  _shuffleArray(array) {
      for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
      }
      return array;
  }
    
  render(c)
  {

  c.save();
 
  c.strokeStyle = "#6f6"; 
  c.shadowColor = "#c2ffc2";
  c.shadowOffsetX = 1;
  c.shadowOffsetY = 1;
  c.shadowBlur = 2;

  c.beginPath(); 

    for (let x = 0; x < this.sz; x ++) {
      for (let y = 0; y < this.sz; y ++) {
        
        if(this.maze[x][y] & cmp.north){
          c.moveTo((x*40), 0.5 + (y*40));
          c.lineTo(((x+1)*40), 0.5 + (y*40));
        }
        
        if(this.maze[x][y] & cmp.east){
          c.moveTo(0.5 + ((x+1)*40), (y*40));
          c.lineTo(0.5 + ((x+1)*40),  ((y+1)*40));
        }
          
        if(this.maze[x][y] & cmp.west){
          c.moveTo(0.5 + (x*40), (y*40));
          c.lineTo(0.5 + (x*40),  ((y+1)*40));
        }
        
          if(this.maze[x][y] & cmp.south){
            c.moveTo((x*40), 0.5 + ((y+1)*40));
            c.lineTo(((x+1)*40), 0.5 + ((y+1)*40));
          }
 
      }
    }

    c.closePath();	
    c.stroke();
    c.restore();
    
  }
}
     
class Player
{
   constructor(c) {
      this.x = 0;
      this.y = -40;
      this.r = 0;
    }
 

hasWon(mz)
{
    let cellX = Math.trunc(this.x/40), cellY = Math.trunc(this.y/40), max = mz.length-1;
    return cellX == max && cellY == max;
}

//canvas, mouse x,y,offsetX,Y
aim(c,x,y,oX,oY){
 
    let r = canvas.getBoundingClientRect(),
     xDif = ((this.x-oX)+20)-(x - r.left),
     yDif = ((this.y-oY)+20)-(y - r.top);

    this.target = (Math.abs(yDif) > Math.abs(xDif)) ? Math.abs(yDif) == yDif ? cmp.north : cmp.south :  Math.abs(xDif) == xDif ? cmp.west : cmp.east;
    this.tx = oX + (x - (r.left));
    this.ty = oY + (y - (r.top));

}
 
  update(mz, keys)
  {
    this.r += this.r>360 ? -360 : 5;

    if(this.y < 0){
      this.y += 1;
      return;
    }

    let cellX = Math.trunc(this.x/40), cellY = Math.trunc(this.y/40), vx = 0, vy = 0, h = 0, w = 0, wall = 0, owall = 0,s = 3; 

    if(keys[37] || this.target == cmp.west){
        vx -=s;
        //Push player to top of the cell so we do not run over any lines
        vy = -(this.y%40);
        wall=cmp.west;
        owall=cmp.east;
        if(this.x+20 <= this.tx){this.target=cmp.none}
    }else if(keys[38] || this.target == cmp.north){
       vy -=s;
       vx = -(this.x%40);
       wall=cmp.north;
       owall=cmp.south;
       if(this.y+20 <= this.ty){this.target=cmp.none}
    }else if(keys[39] || this.target == cmp.east){
       vx = s;
       vy = -(this.y%40);
       w=40;
       wall=cmp.east;
       owall=cmp.west;
       if(this.x+20 >= this.tx){this.target=cmp.none}
    }else if(keys[40] || this.target == cmp.south){
       vy = s;
       vx = -(this.x%40);
       h=40;
       wall=cmp.south;
       owall=cmp.north;
       if(this.y+20 >= this.ty){this.target=cmp.none}
    }

    if(this.x+vx < 0 || this.y+vy < 0){
      return;
    }

    let newCellX = Math.trunc((this.x+w+vx)/40), newCellY = Math.trunc((this.y+h+vy)/40);

    //Collision Detection
    if(cellX!=newCellX || cellY!=newCellY)
    {
      if((mz[cellX][cellY] & wall) == wall || newCellX >= mz.length || newCellY >= mz.length || (mz[newCellX][newCellY] & owall) == owall)
      {  
       //If we hit the wall then place it to the edge of the cell
       if(wall==cmp.north){
          this.y = cellY * 40
       }
       if(wall==cmp.south){
          this.y = (newCellY-1) * 40
       }
       if(wall==cmp.east){
          this.x = (newCellX -1) * 40
       }
       if(wall==cmp.west){
          this.x = cellX * 40
       }

       this.target = cmp.none;
      Snd.hit();
       return;
      }
    } 

    this.x += vx;
    this.y += vy;          
  }

  render(c)
  {
    c.save();

    //player x & y are top left of each cell next line  
    //move to middle to of the cell to begin drawing
    c.translate(this.x+20, this.y+20); 
    c.rotate(this.r * Math.PI / 180);

      let radius = 10, startAngle = 1.25 * Math.PI,  endAngle = 1.85 * Math.PI, cc = false;
 			c.lineWidth = 5;
      c.beginPath();
      c.arc(0,0, radius, startAngle, endAngle, cc);
      c.strokeStyle = "#6f6";
      c.stroke();
      startAngle = 0.25 * Math.PI;
      endAngle = 0.85 * Math.PI;
      c.beginPath();
      c.arc(0, 0, radius, startAngle, endAngle, cc);
      c.strokeStyle = "#6f6";
      c.stroke();           
      radius = 3;
      startAngle = 0 * Math.PI;
      endAngle = 1 * Math.PI;
      c.beginPath();
      c.arc(0, 0, radius, 0, 2 * Math.PI, cc);
      c.fillStyle = "#6f6";
      c.fill();
    c.restore();

  }
}
  class Game
  {
    //cotext,stateChange,timer
    constructor(c,sn,tm) {
      this.ctx = c;
      this.key=[];
      this.stateChange = sn;
      this.state = gs.start;
      this.updateTimer = tm;
    }

    get keys() {
      return this.key;
    }

  
    set state(s)
    {
      this._gState = s;

      if(s==gs.play){
        this.sTime = Date.now();
        this.eTime = null;
      }
      if(s==gs.win)
      {
        this.eTime = Date.now();
        Snd.end();
        Score.set(this.maze.sz, this.eTime-this.sTime)
      }
       if(s==gs.start)
       {
          this.eTime = Date.now();
       }

      this.stateChange(s);
    }

    get state(){
      return this._gState;
    }
 
    quit(){
      this.state = gs.start;
    }

    start(mzSize)
    {
      this.maze = new Maze();
      this.maze.build(mzSize);
      this.player = new Player();
 
      this.glitches = [];
      for(let i = 0;i<mzSize;i++){
        this.glitches.push(new Glitch(mzSize));
      }
      
       this.offSetY = 0;
      this.offSetX = 0;
      this.state = gs.play;   
      
    }

    resize(c,maxW,maxH)
    {
      if(this.maze){
        let sz = this.maze.sz;
        c.width = Math.min(maxW,30+sz*40);
        c.height = Math.min(maxH,30+sz*40);
      }
    }

    aim(x,y){
      this.player.aim(this.ctx.canvas,x,y,this.offSetX,this.offSetY);
    }
    
    update()
    {
      if(this.state!=gs.play) return;
    
      if(this.glitches.filter((g)=>g.isHit && !g.isDead).length == 0){
          this.player.update(this.maze.maze,this.key);
          if(this.player.hasWon(this.maze.maze)) this.state = gs.win;
      }
 
      this.glitches.forEach((g)=>{
        g.update(this.player);
        if(g.isDead) this.maze.build(this.maze.sz);
      });

      this.glitches = this.glitches.filter((g)=>{return !g.isDead}); 

      //update timer 
      let t = (this.eTime ? this.eTime : Date.now()) -  this.sTime;
      let s =  Math.floor((t/1000) % 60);
      let m = Math.floor((t/1000/60) % 60 );
      let ms =  ('0'+Math.floor(t%60)).slice(-2);
      this.updateTimer(s,m,ms);
 
      //Set viewport
      let mSize = this.maze.sz * 40;
      let cWidth = this.ctx.canvas.width;
      let cHeight = this.ctx.canvas.height;

      if(cWidth < mSize)
      {
         this.offSetX = this.player.x > 80 ? Math.min(this.player.x - 80,(mSize-cWidth)+10) : 0;
      }

      if(cHeight < mSize)
      {
        this.offSetY = this.player.y > 80 ? Math.min(this.player.y - 80,(mSize-cHeight)+10) : 0;
      }

}


  
    render(){
 
      //render all game elements
      let c = this.ctx;
      c.clearRect(0, 0, c.canvas.width, c.canvas.height);

      c.translate(-this.offSetX,  -this.offSetY); 

      if(this.state!=gs.play) return;

      this.maze.render(c);
      this.player.render(c);

      this.glitches.forEach((g)=>{
        g.render(c);
      }, this);

       c.translate(this.offSetX,  this.offSetY); 
    }
  }

const g = new Game(document.getElementById("canvas").getContext("2d"),
  (e)=>{
      if(e==gs.play){
        $("footer")[0].classList.remove("hdn");
        $("#starting")[0].classList.add("hdn");
        $("#mz")[0].classList.remove("hdn");
        resizeCanvas()
      }
      if(e==gs.win){
        $("footer")[0].classList.add("hdn");
        $("#end")[0].classList.remove("hdn");
        $("#toptm")[0].innerHTML = "Your Best Time: " + Score.top(g.maze.sz);
      }
    },
  (s,m,ms)=>
      {
          $("#sec")[0].innerText = s;
          $("#min")[0].innerText  = m; 
          $("#ms")[0].innerText  = ms; 
          $("#tm")[0].innerText = `${m}m ${s}s ${ms}ms`; 
      });

lvlSelect = () => {
    $("#lvl")[0].classList.remove("hdn");
  $(".pb-sm")[0].innerText = Score.top(10);
  $(".pb-rg")[0].innerText = Score.top(15);
  $(".pb-lg")[0].innerText = Score.top(20);
  $("#start")[0].classList.add("hdn"); 
  $("#end")[0].classList.add("hdn");
  Snd.start();
}

$(".quit").on("click", ()=>{
   g.quit();
   $("footer")[0].classList.add("hdn");
   lvlSelect();
});

$(".go").on("click", ()=>{
  lvlSelect();
});

$(".snd").on("click", (e)=>{
  Snd.tglMute();
  e.target.classList.toggle('snd-off');
});

$(".lvl").on("click", (e)=>{
  let lvl = e.target.dataset.mz;
  $("#starting")[0].classList.remove("hdn");
  $("#lvl")[0].classList.add("hdn"); 
  var e = $("#starting p")[0];
  Snd.start();
  e.classList.add("cd");
  e.innerText = 3;
  e.on("animationstart", e => {e.target.innerHTML=3;Snd.start()});
  e.on("animationiteration", e => {e.target.innerHTML=3-Math.abs(e.elapsedTime);Snd.start()});
  e.on("animationend", e => {g.start(lvl);Snd.enter(); resizeCanvas()});
});
$("#tw")[0].on("click", ()=>{this.window.location.href="https://twitter.com/intent/tweet?text=I%20have%20just%20escaped%20maze%2013%20in%20" + encodeURIComponent($("#tm")[0].innerText) + "%20at%20" + encodeURIComponent(this.window.location.href) + "&hashtags=js13k,maze13&via=johnkilmister"});
 $("#canvas").on("click", (e)=>{g.aim(e.clientX,e.clientY)});
document.onkeydown = (e) =>{g.keys[e.keyCode]=true;}
document.onkeyup = (e) =>{g.keys[e.keyCode]=null;}

(function () {
  function main(tFrame) {
    g.stopMain = window.requestAnimationFrame(main);
    
    g.update(tFrame);  
    g.render();
  }
  
  main(); 
})();
 

 function resizeCanvas()
 {
    let m = $("main")[0],
    maxW =  m.offsetWidth-30,
    maxH = m.offsetHeight-30;
    g.resize($("canvas")[0],maxW,maxH)
 }